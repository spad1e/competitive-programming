#include <bits/stdc++.h>
#include "underground.h"
//#include "grader.cpp"
#define pii pair<int, int>
#define st first
#define nd second
#define INF INT_MAX
using namespace std;

const int N = 501;
int dp[N][N][16];
int A[N][N];
bool vis[N][N];
priority_queue<pair<int, pii>> pq;

int dig_paths(int R, int C, vector<vector<int>>& a) {
    for (int i = 1; i <= R; ++i)
        for (int j = 1; j <= C; ++j)
            for (int k = 0; k < 16; ++k)
                dp[i][j][k] = 1e9, A[i][j];

    dp[1][1][1] = A[0][0];
    dp[1][C][2] = A[0][C-1];
    dp[R][1][4] = A[R-1][0];
    dp[R][C][8] = A[R-1][C-1];

    for (int k = 1; k < 16; ++k) {
        for (int s = 0; s < 4; ++s) {
            if (!k&(1<<s)) continue;
            for (int i = 1; i <= R; ++i) {
                for (int j = 1; j <= C; ++j) {
                    dp[i][j][k] = min(dp[i][j][k], dp[i][j][k^(1<<s)] + dp[i][j][(1<<s)] - A[i-1][j-1]);
                }
            }
        }
        for (int x = 1; x <= R; ++x) {
            for (int y = 1; y <= C; ++y) {
                vis[x][y] = 0;
                if (dp[x][y][k] == 1e9) continue;
                if (x+1<=R && dp[x+1][y][k] + A[x-1][y-1] < dp[x][y][k]) continue;
                if (y+1<=C && dp[x][y+1][k] + A[x-1][y-1] < dp[x][y][k]) continue;
                if (x-1>=1 && dp[x-1][y][k] + A[x-1][y-1] < dp[x][y][k]) continue;
                if (y-1>=1 && dp[x][y-1][k] + A[x-1][y-1] < dp[x][y][k]) continue;
                pq.push({-dp[x][y][k], {x, y}});
            }
        }
        while (!pq.empty()) {
            auto [x, y] = pq.top().nd; pq.pop();
            if (vis[x][y]) continue;
            vis[x][y] = 1;
            if (x+1<=R && !vis[x+1][y] && dp[x+1][y][k] > dp[x][y][k] + A[x][y-1])
                dp[x+1][y][k] = dp[x][y][k] + A[x][y-1], pq.push({-dp[x+1][y][k], {x+1, y}});
            if (y+1<=C && !vis[x][y+1] && dp[x][y+1][k] > dp[x][y][k] + A[x-1][y])
                dp[x][y+1][k] = dp[x][y][k] + A[x-1][y], pq.push({-dp[x][y+1][k], {x, y+1}});
            if (x-1>=1 && !vis[x-1][y] && dp[x-1][y][k] > dp[x][y][k] + A[x-2][y-1])
                dp[x-1][y][k] = dp[x][y][k] + A[x-2][y-1], pq.push({-dp[x-1][y][k], {x-1, y}});
            if (y-1>=1 && !vis[x][y-1] && dp[x][y-1][k] > dp[x][y][k] + A[x-1][y-2])
                dp[x][y-1][k] = dp[x][y][k] + A[x-1][y-2], pq.push({-dp[x][y-1][k], {x, y-1}});
        }
    }


    int ans = INT_MAX;
    for (int i = 1; i <= R; ++i) for (int j = 1; j <= C; ++j) ans = min(ans, dp[i][j][15]);
    return ans;
}
